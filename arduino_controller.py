import serial
import threading

class Controller():
  
  codes = [20673336500502904] # Example id

  def start(self):
    """
    Initializes the connection to the arduino,
    and begins listening for codes / prints.
    Must be run before write commands can be issued.
    """

    # Check that arduino is connected
    try:
      self.ser = serial.Serial('/dev/cu.usbmodem1411', 9600)
    except serial.SerialException as e:
      print(str(e))
      print('NOTE: is arduino conneted?')
      return

    # Creates a daemon thread for listening to 
    t = threading.Thread(target=self.read, daemon=True)
    t.start()

  def read(self):
    """
    Is run as a daemon thread, listens to arduino,
    captures any codes and adds them to the list,
    prints any prints.
    """
    print('Controller Listening...')

    # Check arduino is listening
    listening_line = self.ser.readline()
    if (listening_line == b'Arduino listening...\r\n'):
      print('Arduino listening...')
    else:
      print('WARNING: Arduino may not be listening')

    while True:
      # Read in line
      line = self.ser.readline()
      # Remove '\r\n' and decode
      line = line[:-2].decode("utf-8")

      # if it starts with 'print', print it
      if line.startswith('print'):
        print(line)
      # Otherwise interpret it as a card code
      else:
        # Parse to an int
        code = int(line, 2)
        self.codes.append(code)

        print(f'Code recieved: {line} {code}')
        print(f'Current codes: {self.codes}')


  def write(self, index):
    """
    Given an index int for the list of collected codes in
    self.codes, send that code to the arduino
    (to be sent to the door control server)
    """
    print(f'Selecting code {index}: {self.codes[index]}')
    write_bytes = (self.codes[index]).to_bytes(7, 'big')
    print(write_bytes)
    self.ser.write(write_bytes)
    return 'Sent to arduino.'

